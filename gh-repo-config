#!/usr/bin/env bash
set -o errexit -o errtrace -o nounset -o pipefail

APP_NAME="$(basename "$0")"
APP_VERSION="1.0.0"
APP_CONFIG=".github/config"
APP_CMD="help"

# `APP_ENV` is set by `make test`.
# `_GH` allows us to mock the `gh` binary in tests (see apply.bats).
APP_ENV="${APP_ENV:-}"
if [ "${APP_ENV}" == "test" ]; then
    _GH="${_GH:-false}"
else
    _GH="gh"
fi

JSON_REPO_Q=$(
    cat <<'EOL'
{
    "name": .name,
    "description": .description,
    "homepage": .homepage,
    "private": .private,
    "visibility": .visibility,
    "has_issues": .has_issues,
    "has_projects": .has_projects,
    "has_wiki": .has_wiki,
    "default_branch": .default_branch,
    "allow_squash_merge": .allow_squash_merge,
    "allow_merge_commit": .allow_merge_commit,
    "allow_rebase_merge": .allow_rebase_merge,
    "allow_auto_merge": .allow_auto_merge,
    "delete_branch_on_merge": .delete_branch_on_merge,
    "allow_update_branch": .allow_update_branch,
    "use_squash_pr_title_as_default": .use_squash_pr_title_as_default,
    "archived": .archived,
    "web_commit_signoff_required": .web_commit_signoff_required
}
EOL
)

JSON_BRANCH_PROTECTION_Q=$(
    cat <<'EOL'
{
    "enforce_admins": .enforce_admins.enabled,
    "required_pull_request_reviews": .required_pull_request_reviews,
    "required_status_checks": .required_status_checks,
    "restrictions": .restrictions,
    "required_linear_history": .required_linear_history.enabled,
    "allow_force_pushes": .allow_force_pushes.enabled,
    "allow_deletions": .allow_deletions.enabled,
    "block_creations": .block_creations.enabled,
    "required_conversation_resolution": .required_conversation_resolution.enabled,
    "lock_branch": .lock_branch.enabled,
    "allow_fork_syncing": .allow_fork_syncing.enabled
}
EOL
)

log() {
    local -r msg="$1"
    printf "%s\n" "${msg}" >/dev/stderr
}

log:action() {
    local -r action="$1"
    local -r msg="$2"
    if [ $# -gt 2 ]; then
        local -r eol="$3"
    else
        local -r eol="\n"
    fi
    printf "[%s]: %s%b" "${action}" "${msg}" "${eol}" >/dev/stderr
}

log:api() {
    local -r repo="$1"
    local -r msg="$2"
    printf "[%s]: %s\n" "${repo}" "${msg}" >/dev/stderr
}

app::apply() {
    repo=$("${_GH}" repo view --json nameWithOwner --jq .nameWithOwner)

    if [ -f "${APP_CONFIG}/repo.json" ]; then
        log:api "${repo}" "Configuring repo"
        "${_GH}" api -X PATCH /repos/:owner/:repo \
            --input="${APP_CONFIG}/repo.json" >/dev/null
    fi

    if [ -f "${APP_CONFIG}/topics.json" ]; then
        log:api "${repo}" "Configuring repo topics"
        "${_GH}" api -X PUT /repos/:owner/:repo/topics \
            --input="${APP_CONFIG}/topics.json" >/dev/null
    fi

    if [ -d "${APP_CONFIG}/branch-protection" ]; then
        for filepath in "${APP_CONFIG}/branch-protection/"*; do
            branch=$(basename "${filepath}" ".json")
            log:api "${repo}" "Configuring branch protection rules for '${branch}'"
            "${_GH}" api -X PUT "/repos/:owner/:repo/branches/${branch}/protection" \
                --input="${filepath}" >/dev/null
        done
    fi
}

app::confirm() {
    local response
    while true; do
        read -r -p "${1:-Confirm?} [y/N]: " response
        case $response in
        [Yy]*) return 0 ;;
        [Nn]* | "") return 1 ;;
        *) echo "Please answer Y or N" ;;
        esac
    done
}

app::help() {
    echo "Manage GitHub repository settings via declarative configuration."
    echo ""
    echo "Usage:"
    echo "  gh repo-config <command> [<flags>]"
    echo ""
    echo "Commands:"
    echo "  apply:      Apply config"
    echo "  init:       Initialize a config directory"
    echo ""
    echo "Examples:"
    echo "  $ gh repo-config init"
    echo "  $ gh repo-config apply"
    echo ""
    echo "  # Specifying an alternate config directory:"
    echo "  $ gh repo-config init --config ./repo-settings"
    echo "  $ gh repo-config apply --config ./repo-settings"
    echo ""
    echo "Options:"
    echo "  -c, --config <dir>   Config directory [default: ${APP_CONFIG}]."
    echo "  -h, --help           Show usage."
    echo "  -v, --version        Show version."
    echo ""
}

app::init() {
    local -r branch="$(git rev-parse --abbrev-ref HEAD)"
    log "Initializing config..."
    app::init_dir "${APP_CONFIG}"
    echo "*" > "${APP_CONFIG}/.gitignore"
    app::init_file_source "${APP_CONFIG}/repo.json" "/repos/:owner/:repo" "$JSON_REPO_Q"
    app::init_file_source "${APP_CONFIG}/topics.json" "/repos/:owner/:repo/topics" "."
    app::init_dir "${APP_CONFIG}/branch-protection"
    app::init_file_source "${APP_CONFIG}/branch-protection/${branch}.json" "/repos/:owner/:repo/branches/${branch}/protection" "$JSON_BRANCH_PROTECTION_Q"
    log "Done"
}

app::init_dir() {
    local -r path="$1"
    if [ -d "${path}" ]; then
        log:action "found" "${path}"
    else
        log:action "create" "${path}"
        mkdir -p "${path}"
    fi
}

app::init_file_source() {
    local -r path="$1"
    local -r content="$(${_GH} api ${2} | jq "${3}")"
    if [ -f "${path}" ]; then
        log:action "warn" "${path} already exists!"
        if app::confirm "Overwrite?"; then
            log:action "replace" "${path}"
            echo "${content}" >"${path}"
        else
            log:action "keep" "${path}"
        fi
    else
        log:action "create" "${path}"
        echo "${content}" >"${path}"
    fi
}

app::unknown() {
    local -r arg="$1"
    echo "Unknown argument '${arg}'"
}

app::version() {
    echo "${APP_NAME} version ${APP_VERSION}"
}

app::parseargs() {
    while test $# -gt 0; do
        case "${1}" in
        apply | help | init | version)
            APP_CMD="${1}"
            shift
            ;;
        -c | --config)
            APP_CONFIG="${2:?empty config path not allowed}"
            shift 2
            ;;
        -h | --help)
            APP_CMD="help"
            shift
            ;;
        --version)
            APP_CMD="version"
            shift
            ;;
        *)
            app::unknown "$1"
            exit 1
            ;;
        esac
    done
}

app::dispatch() {
    case "${1}" in
    apply) app::apply ;;
    help) app::help ;;
    init) app::init ;;
    version) app::version ;;
    esac
}

app::parseargs "$@"
app::dispatch "$APP_CMD"
